-- Booting
local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()
local Window = Rayfield:CreateWindow({
    Name = "Sora",
    Icon = "cat",
    LoadingTitle = "Sora Hub",
    LoadingSubtitle = "Created by XEM",
    ShowText = "Sora",
    Theme = "Amethyst",
    ToggleUIKeybind = "K",
    DisableRayfieldPrompts = false,
    DisableBuildWarnings = false,
    ConfigurationSaving = {
        Enabled = true,
        FolderName = nil,
        FileName = "Sora Hub Essential"
    },
    Discord = {
        Enabled = true,
        Invite = "3znSHHRVg7",
        RememberJoins = true
    },
    KeySystem = false,
    KeySettings = {
        Title = "Untitled",
        Subtitle = "Key System",
        Note = "No method of obtaining the key is provided",
        FileName = "Key",
        SaveKey = true,
        GrabKeyFromSite = false,
        Key = {"Hello"}
    }
})

Rayfield:Notify({
    Title = "Sora",
    Content = "Sora has been executed.",
    Duration = 6.5,
    Image = "check",
})

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local HttpService = game:GetService("HttpService")
local TweenService = game:GetService("TweenService")

-- Player setup
local player = Players.LocalPlayer
repeat wait() until player.Character
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local rootPart = character:WaitForChild("HumanoidRootPart")

-- Variables
local isRecording = false
local isPlaying = false
local recordedData = {}
local recordingConnection
local playbackConnection
local recordingStartTime = 0
local playbackStartTime = 0

-- Recording functions dengan timing yang presisi
local function getCharacterData()
    if character and character.Parent and rootPart and humanoid then
        return {
            position = {rootPart.Position.X, rootPart.Position.Y, rootPart.Position.Z},
            cframe = {rootPart.CFrame:GetComponents()},
            velocity = {rootPart.Velocity.X, rootPart.Velocity.Y, rootPart.Velocity.Z},
            timestamp = tick() - recordingStartTime,
            walkSpeed = humanoid.WalkSpeed,
            jumpPower = humanoid.JumpPower,
            moveDirection = {humanoid.MoveDirection.X, humanoid.MoveDirection.Y, humanoid.MoveDirection.Z},
            humanoidState = humanoid:GetState()
        }
    end
    return nil
end

-- Smooth interpolation untuk movement yang natural
local function lerpVector3(a, b, t)
    return a + (b - a) * t
end

local function lerpCFrame(a, b, t)
    return a:Lerp(b, t)
end

-- Calculate movement direction dari position changes
local function calculateMovementDirection(currentPos, nextPos)
    if not nextPos then return Vector3.new(0, 0, 0) end
    
    local direction = (nextPos - currentPos)
    local horizontalDirection = Vector3.new(direction.X, 0, direction.Z)
    
    if horizontalDirection.Magnitude > 0.1 then
        return horizontalDirection.Unit
    end
    return Vector3.new(0, 0, 0)
end

local function setCharacterData(data, nextData, lerpFactor)
    if not character or not character.Parent or not rootPart or not data then return end
    
    local currentPos = Vector3.new(data.position[1], data.position[2], data.position[3])
    local currentCFrame = CFrame.new(unpack(data.cframe))
    local nextPos = nil
    
    -- Interpolasi dengan frame berikutnya jika ada
    if nextData and lerpFactor then
        nextPos = Vector3.new(nextData.position[1], nextData.position[2], nextData.position[3])
        local nextCFrame = CFrame.new(unpack(nextData.cframe))
        
        currentPos = lerpVector3(currentPos, nextPos, lerpFactor)
        currentCFrame = lerpCFrame(currentCFrame, nextCFrame, lerpFactor)
    end
    
    -- Set position dengan smooth movement
    rootPart.CFrame = currentCFrame
    
    -- Set velocity untuk realistic physics
    if data.velocity then
        rootPart.Velocity = Vector3.new(data.velocity[1], data.velocity[2], data.velocity[3])
    end
    
    -- Set humanoid properties
    if data.walkSpeed then
        humanoid.WalkSpeed = data.walkSpeed
    end
    if data.jumpPower then
        humanoid.JumpPower = data.jumpPower
    end
    
    -- Calculate movement direction untuk animasi yang konsisten
    local moveDirection = Vector3.new(0, 0, 0)
    
    -- Prioritas 1: Gunakan recorded movement direction jika ada
    if data.moveDirection then
        local recordedMoveDir = Vector3.new(data.moveDirection[1], data.moveDirection[2], data.moveDirection[3])
        if recordedMoveDir.Magnitude > 0.05 then
            moveDirection = recordedMoveDir
        end
    end
    
    -- Prioritas 2: Calculate dari position change jika tidak ada recorded direction
    if moveDirection.Magnitude < 0.05 and nextData then
        moveDirection = calculateMovementDirection(
            Vector3.new(data.position[1], data.position[2], data.position[3]),
            Vector3.new(nextData.position[1], nextData.position[2], nextData.position[3])
        )
    end
    
    -- Prioritas 3: Calculate dari velocity jika masih tidak ada
    if moveDirection.Magnitude < 0.05 and data.velocity then
        local velocityDir = Vector3.new(data.velocity[1], 0, data.velocity[3])
        if velocityDir.Magnitude > 2 then
            moveDirection = velocityDir.Unit
        end
    end
    
    -- Apply movement direction untuk animasi walking
    if moveDirection.Magnitude > 0.05 then
        humanoid:Move(moveDirection, false)
        
        -- Ensure walking animation dengan set state
        if humanoid:GetState() ~= Enum.HumanoidStateType.Jumping and 
           humanoid:GetState() ~= Enum.HumanoidStateType.Freefall then
            humanoid:ChangeState(Enum.HumanoidStateType.Running)
        end
    else
        -- Stop movement jika tidak ada direction
        humanoid:Move(Vector3.new(0, 0, 0), false)
    end
    
    -- Handle jumping state
    if data.humanoidState == Enum.HumanoidStateType.Jumping then
        humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
    elseif data.humanoidState == Enum.HumanoidStateType.Freefall then
        humanoid:ChangeState(Enum.HumanoidStateType.Freefall)
    end
end

local function startRecording()
    if isRecording then return end
    
    if not character or not rootPart or not humanoid then
        Rayfield:Notify({
            Title = "Error",
            Content = "Character not found!",
            Duration = 3,
            Image = "alert-triangle",
        })
        return
    end
    
    isRecording = true
    recordedData = {}
    recordingStartTime = tick()
    
    Rayfield:Notify({
        Title = "Recording",
        Content = "Started high-precision recording...",
        Duration = 3,
        Image = "play-circle",
    })
    
    -- Record dengan frequency tinggi untuk smooth playback
    recordingConnection = RunService.Heartbeat:Connect(function()
        if not isRecording then return end
        
        local data = getCharacterData()
        if data then
            table.insert(recordedData, data)
        end
    end)
end

local function stopRecording()
    if not isRecording then return end
    
    isRecording = false
    
    if recordingConnection then
        recordingConnection:Disconnect()
        recordingConnection = nil
    end
    
    Rayfield:Notify({
        Title = "Recording",
        Content = "Stopped recording. Frames: " .. #recordedData,
        Duration = 3,
        Image = "stop-circle",
    })
end

local function startPlayback()
    if #recordedData == 0 then
        Rayfield:Notify({
            Title = "Error",
            Content = "No recorded data to play!",
            Duration = 3,
            Image = "alert-triangle",
        })
        return
    end
    
    if isPlaying then return end
    
    if not character or not rootPart or not humanoid then
        Rayfield:Notify({
            Title = "Error",
            Content = "Character not found!",
            Duration = 3,
            Image = "alert-triangle",
        })
        return
    end
    
    isPlaying = true
    playbackStartTime = tick()
    
    -- Disable player control selama playback
    local originalPlatformStand = humanoid.PlatformStand
    humanoid.PlatformStand = true
    
    -- Force walking animation dari start
    local firstMoveDirection = Vector3.new(0, 0, 0)
    if #recordedData >= 2 then
        local firstPos = Vector3.new(recordedData[1].position[1], recordedData[1].position[2], recordedData[1].position[3])
        local secondPos = Vector3.new(recordedData[2].position[1], recordedData[2].position[2], recordedData[2].position[3])
        firstMoveDirection = calculateMovementDirection(firstPos, secondPos)
    end
    
    -- Start walking animation immediately
    if firstMoveDirection.Magnitude > 0.05 then
        humanoid:Move(firstMoveDirection, false)
        humanoid:ChangeState(Enum.HumanoidStateType.Running)
    end
    
    Rayfield:Notify({
        Title = "Auto Summit",
        Content = "Starting natural walking...",
        Duration = 3,
        Image = "play",
    })
    
    playbackConnection = RunService.Heartbeat:Connect(function()
        if not isPlaying then return end
        
        local currentTime = tick() - playbackStartTime
        local currentFrame = nil
        local nextFrame = nil
        local lerpFactor = 0
        
        -- Find current frame berdasarkan timestamp
        for i = 1, #recordedData - 1 do
            local thisFrame = recordedData[i]
            local nextFrameData = recordedData[i + 1]
            
            if currentTime >= thisFrame.timestamp and currentTime <= nextFrameData.timestamp then
                currentFrame = thisFrame
                nextFrame = nextFrameData
                
                -- Calculate interpolation factor
                local frameDuration = nextFrameData.timestamp - thisFrame.timestamp
                if frameDuration > 0 then
                    lerpFactor = (currentTime - thisFrame.timestamp) / frameDuration
                    lerpFactor = math.max(0, math.min(1, lerpFactor))
                end
                break
            end
        end
        
        -- Jika sudah melewati semua frame, gunakan frame terakhir
        if not currentFrame and currentTime > recordedData[#recordedData].timestamp then
            currentFrame = recordedData[#recordedData]
            -- Maintain walking animation sampai akhir
            if currentFrame and currentFrame.moveDirection then
                local finalMoveDir = Vector3.new(currentFrame.moveDirection[1], currentFrame.moveDirection[2], currentFrame.moveDirection[3])
                if finalMoveDir.Magnitude > 0.05 then
                    humanoid:Move(finalMoveDir, false)
                    wait(0.5) -- Beri waktu untuk animasi selesai natural
                end
            end
            isPlaying = false
        end
        
        -- Set character data dengan interpolation
        if currentFrame then
            setCharacterData(currentFrame, nextFrame, lerpFactor)
        end
        
        -- Stop playback jika selesai
        if not isPlaying then
            -- Smooth stop animation
            humanoid:Move(Vector3.new(0, 0, 0), false)
            humanoid:ChangeState(Enum.HumanoidStateType.Landed)
            humanoid.PlatformStand = originalPlatformStand
            
            if playbackConnection then
                playbackConnection:Disconnect()
                playbackConnection = nil
            end
            
            Rayfield:Notify({
                Title = "Auto Summit",
                Content = "Natural walking completed!",
                Duration = 3,
                Image = "check-circle",
            })
        end
    end)
end

local function stopPlayback()
    if not isPlaying then return end
    
    isPlaying = false
    
    -- Natural stop animation
    if humanoid then
        humanoid:Move(Vector3.new(0, 0, 0), false)
        humanoid:ChangeState(Enum.HumanoidStateType.Landed)
        wait(0.3) -- Allow animation to settle
        humanoid.PlatformStand = false
    end
    
    if playbackConnection then
        playbackConnection:Disconnect()
        playbackConnection = nil
    end
    
    Rayfield:Notify({
        Title = "Auto Summit",
        Content = "Walking stopped naturally!",
        Duration = 3,
        Image = "stop-circle",
    })
end

local function exportData()
    if #recordedData == 0 then
        Rayfield:Notify({
            Title = "Export",
            Content = "No data to export!",
            Duration = 3,
            Image = "alert-triangle",
        })
        return
    end
    
    local success, exportString = pcall(function()
        return HttpService:JSONEncode(recordedData)
    end)
    
    if success then
        if setclipboard then
            setclipboard(exportString)
            Rayfield:Notify({
                Title = "Export",
                Content = "Data copied to clipboard! (" .. #recordedData .. " frames)",
                Duration = 3,
                Image = "clipboard",
            })
        else
            -- Create export window dengan scroll
            local ExportGui = Instance.new("ScreenGui")
            local Frame = Instance.new("Frame")
            local ScrollingFrame = Instance.new("ScrollingFrame")
            local TextBox = Instance.new("TextBox")
            local CloseButton = Instance.new("TextButton")
            local CopyLabel = Instance.new("TextLabel")
            
            ExportGui.Parent = player:WaitForChild("PlayerGui")
            ExportGui.Name = "ExportData"
            
            Frame.Parent = ExportGui
            Frame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
            Frame.BorderSizePixel = 2
            Frame.BorderColor3 = Color3.fromRGB(100, 100, 100)
            Frame.Position = UDim2.new(0.1, 0, 0.1, 0)
            Frame.Size = UDim2.new(0.8, 0, 0.8, 0)
            Frame.Active = true
            Frame.Draggable = true
            
            CopyLabel.Parent = Frame
            CopyLabel.BackgroundTransparency = 1
            CopyLabel.Position = UDim2.new(0, 10, 0, 10)
            CopyLabel.Size = UDim2.new(1, -100, 0, 30)
            CopyLabel.Font = Enum.Font.SourceSansBold
            CopyLabel.Text = "High-Precision Data (" .. #recordedData .. " frames):"
            CopyLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
            CopyLabel.TextSize = 16
            CopyLabel.TextXAlignment = Enum.TextXAlignment.Left
            
            ScrollingFrame.Parent = Frame
            ScrollingFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
            ScrollingFrame.BorderSizePixel = 1
            ScrollingFrame.BorderColor3 = Color3.fromRGB(100, 100, 100)
            ScrollingFrame.Position = UDim2.new(0, 10, 0, 50)
            ScrollingFrame.Size = UDim2.new(1, -20, 1, -90)
            ScrollingFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
            ScrollingFrame.ScrollBarThickness = 10
            
            TextBox.Parent = ScrollingFrame
            TextBox.BackgroundTransparency = 1
            TextBox.Position = UDim2.new(0, 0, 0, 0)
            TextBox.Size = UDim2.new(1, -10, 1, 0)
            TextBox.Text = exportString
            TextBox.TextColor3 = Color3.fromRGB(255, 255, 255)
            TextBox.TextSize = 10
            TextBox.MultiLine = true
            TextBox.ClearTextOnFocus = false
            TextBox.Font = Enum.Font.SourceSans
            TextBox.TextYAlignment = Enum.TextYAlignment.Top
            TextBox.TextWrapped = true
            
            -- Auto-size the canvas
            local textSize = game:GetService("TextService"):GetTextSize(
                exportString, 10, Enum.Font.SourceSans, 
                Vector2.new(ScrollingFrame.AbsoluteSize.X - 10, math.huge)
            )
            ScrollingFrame.CanvasSize = UDim2.new(0, 0, 0, textSize.Y + 20)
            TextBox.Size = UDim2.new(1, -10, 0, textSize.Y + 20)
            
            CloseButton.Parent = Frame
            CloseButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
            CloseButton.BorderSizePixel = 0
            CloseButton.Position = UDim2.new(1, -80, 0, 10)
            CloseButton.Size = UDim2.new(0, 70, 0, 30)
            CloseButton.Text = "Close"
            CloseButton.TextColor3 = Color3.fromRGB(255, 255, 255)
            CloseButton.TextSize = 14
            CloseButton.Font = Enum.Font.SourceSansBold
            
            CloseButton.MouseButton1Click:Connect(function()
                ExportGui:Destroy()
            end)
            
            Rayfield:Notify({
                Title = "Export",
                Content = "High-precision data exported to window!",
                Duration = 3,
                Image = "file-text",
            })
        end
    else
        Rayfield:Notify({
            Title = "Export",
            Content = "Failed to export data!",
            Duration = 3,
            Image = "alert-triangle",
        })
    end
end

local function importData(dataString)
    if not dataString or dataString == "" then
        Rayfield:Notify({
            Title = "Import",
            Content = "No data provided!",
            Duration = 3,
            Image = "alert-triangle",
        })
        return false
    end
    
    local success, decodedData = pcall(function()
        return HttpService:JSONDecode(dataString)
    end)
    
    if success and type(decodedData) == "table" and #decodedData > 0 then
        recordedData = decodedData
        
        -- Calculate duration
        local duration = 0
        if #recordedData > 0 then
            duration = recordedData[#recordedData].timestamp
        end
        
        Rayfield:Notify({
            Title = "Import",
            Content = string.format("Imported %d frames (%.1fs duration)!", #recordedData, duration),
            Duration = 3,
            Image = "download",
        })
        return true
    else
        Rayfield:Notify({
            Title = "Import",
            Content = "Failed to import! Invalid data format.",
            Duration = 3,
            Image = "alert-triangle",
        })
        return false
    end
end

-- Character respawn handler
player.CharacterAdded:Connect(function(char)
    character = char
    humanoid = char:WaitForChild("Humanoid")
    rootPart = char:WaitForChild("HumanoidRootPart")
    
    -- Stop any ongoing operations
    if isRecording then
        stopRecording()
    end
    if isPlaying then
        stopPlayback()
    end
    
    Rayfield:Notify({
        Title = "Character",
        Content = "Character respawned - Operations reset!",
        Duration = 2,
        Image = "user",
    })
end)

-- Script Maker Tab
local ScriptMakerTab = Window:CreateTab("Script Maker", "file-code-2")
local RecordingSection = ScriptMakerTab:CreateSection("High-Precision Recording")

local RecordButton = ScriptMakerTab:CreateButton({
    Name = "🔴 Start Recording",
    Callback = function()
        startRecording()
    end,
})

local StopRecordButton = ScriptMakerTab:CreateButton({
    Name = "⏹️ Stop Recording",
    Callback = function()
        stopRecording()
    end,
})

local PlaybackSection = ScriptMakerTab:CreateSection("Smooth Playback")

local PlayButton = ScriptMakerTab:CreateButton({
    Name = "▶️ Start Auto Summit",
    Callback = function()
        startPlayback()
    end,
})

local StopPlayButton = ScriptMakerTab:CreateButton({
    Name = "⏹️ Stop Auto Summit",
    Callback = function()
        stopPlayback()
    end,
})

local DataSection = ScriptMakerTab:CreateSection("Data Management")

local ExportButton = ScriptMakerTab:CreateButton({
    Name = "📁 Export Precision Data",
    Callback = function()
        exportData()
    end,
})

local ImportInput = ScriptMakerTab:CreateInput({
    Name = "📥 Import Path Data",
    PlaceholderText = "Paste high-precision JSON data here...",
    RemoveTextAfterFocusLost = false,
    Callback = function(text)
        if text and text ~= "" then
            importData(text)
        end
    end,
})

-- Status Section
local StatusSection = ScriptMakerTab:CreateSection("Status Monitor")
local StatusLabel = ScriptMakerTab:CreateLabel("Status: Ready")
local DataLabel = ScriptMakerTab:CreateLabel("Recorded Data: None")

-- Update status dengan info lebih detail
spawn(function()
    while true do
        wait(0.5)
        local status = "Ready"
        if isRecording then
            status = "🔴 Recording... (Frame: " .. #recordedData .. ")"
        elseif isPlaying then
            local currentTime = tick() - playbackStartTime
            local totalTime = #recordedData > 0 and recordedData[#recordedData].timestamp or 0
            local progress = totalTime > 0 and (currentTime / totalTime * 100) or 0
            status = string.format("▶️ Playing... (%.1f%%)", math.min(progress, 100))
        end
        StatusLabel:Set("Status: " .. status)
        
        -- Data info
        local dataInfo = "Recorded Data: None"
        if #recordedData > 0 then
            local duration = recordedData[#recordedData].timestamp
            dataInfo = string.format("Recorded Data: %d frames (%.1fs)", #recordedData, duration)
        end
        DataLabel:Set(dataInfo)
    end
end)

-- Keybinds
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    
    if input.KeyCode == Enum.KeyCode.R then
        if isRecording then
            stopRecording()
        else
            startRecording()
        end
    elseif input.KeyCode == Enum.KeyCode.P then
        if isPlaying then
            stopPlayback()
        else
            startPlayback()
        end
    end
end)

-- Info Tab
local InfoTab = Window:CreateTab("Instructions", "info")
local GuideSection = InfoTab:CreateSection("Precision Recording Guide")

InfoTab:CreateLabel("🎯 High-Precision System:")
InfoTab:CreateLabel("• Records every frame at 60+ FPS")
InfoTab:CreateLabel("• Captures position, rotation, velocity & state")
InfoTab:CreateLabel("• Uses smooth interpolation for playback")
InfoTab:CreateLabel("• Maintains exact timing and movement")

InfoTab:CreateLabel("")
InfoTab:CreateLabel("📝 Usage Steps:")
InfoTab:CreateLabel("1. Position yourself at start point")
InfoTab:CreateLabel("2. Press 'Start Recording' (or R key)")
InfoTab:CreateLabel("3. Move naturally - walk, run, jump normally")
InfoTab:CreateLabel("4. Press 'Stop Recording' when done")
InfoTab:CreateLabel("5. Export data to save your exact movement")
InfoTab:CreateLabel("6. Import data to load saved movements")
InfoTab:CreateLabel("7. Start Auto Summit for perfect playback")

local KeybindSection = InfoTab:CreateSection("Controls")
InfoTab:CreateLabel("🎮 Keyboard Shortcuts:")
InfoTab:CreateLabel("R - Toggle Recording")
InfoTab:CreateLabel("P - Toggle Smooth Playback") 
InfoTab:CreateLabel("K - Toggle UI")

local TechnicalSection = InfoTab:CreateSection("Technical Info")
InfoTab:CreateLabel("⚙️ System Features:")
InfoTab:CreateLabel("• Frame-perfect timing synchronization")
InfoTab:CreateLabel("• Smooth interpolation between frames")
InfoTab:CreateLabel("• Velocity and physics preservation")
InfoTab:CreateLabel("• Humanoid state management")
InfoTab:CreateLabel("• Player control disable during playback")
InfoTab:CreateLabel("• Automatic character respawn handling")